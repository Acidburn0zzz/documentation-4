[[components]]
== CFEngine Components

CFEngine is comprised of a number of components. In this chapter we'll
consider how to build them and what they are for.

=== Core Components

You can think of CFEngine like an orchestra. It is composed of any
number of computers (players), each of which has its own copy of the
music and knows what to play.

CFEngine's software agents are independent components that run on each
individual computer. They can communicate if they need to, as shown in
the following figure. This means you don't have to arrange risky login
credentials to run your network â€“ and if something goes wrong with the
communications network, CFEngine is where it needs to be to repair or
protect the system during the outage.

image:fig/components-overview.png[]

If the network is not working, CFEngine just skips these parts and
continues with what it can do. It is fault tolerant and opportunistic.

cf-promises::
    The promise verifier and compiler. This is used to run a
    "pre-check" of configuration promises before attempting to
    execute.

cf-agent::
    This is the instigator of change. The agent is the part of
    CFEngine that manipulates system resources.

cf-serverd::
    The server is able to share files and receive requests to execute
    existing policy on an individual machine. It is not possible to
    send (push) new information to CFEngine from outside. 

cf-execd::
    This is a scheduling daemon (which can either supplement or
    replace cron). It also works as a wrapper, executing and
    collecting the output of cf-agent and E-mailing it if necessary to
    a system account.

cf-runagent::
    This is a helper program that can talk to cf-serverd and request
    that it execute cf-agent with its existing policy. It can thus be
    used to simulate a push of changes to CFEngine hosts, if their
    policy includes that they check for updates.
 
cf-report::
    This generates summary and other reports in a variety of formats
    for export or integration with other systems.

cf-know::
   This agent can generate an ISO standard Topic Map from a number of
   promises about system knowledge. It is used for rendering
   documentation as a 'semantic web'.

=== CFEngine Architecture

CFEngine operates autonomously in a network, under your guidance. If
your site is large (thousands of servers) you should spend some time
discussing with CFEngine experts how to tune this description to your
environment as scale requires you to have more infrastructure, and a
potentially more complicated configuration. The essence of any
CFEngine deployment is the same.

There are four commonly cited phases in managing systems, summarized
as follows: Build, Deploy, Manage, and Audit.

These separate phases originate with a model of system management
based on transactional changes. CFEngine's conception of management is
somewhat different, as transaction processing is not a good model for
system management, but we can use this template to see how CFEngine
works differently.

Build::
    A system is based on a number of decisions and resources that need
    to be `built' before they can be implemented. Building the trusted
    foundations of a  system is the key to guiding its development.
    You don't need to decide every detail, just enough to build trust
    and predictability into your system. In CFEngine, what you build
    is a template of proposed promises for the machines in an
    organization such that, if the machines all make and keep these
    promises, the system will function seamlessly as planned. This is
    how it works in a human organization, and this is how is works for
    computers too. 

Deploy::
    Deploying really means implementing the policy that was already
    decided. In transaction systems, one tries to push out changes one
    by one, hence `deploying' the decision. In CFEngine you simply
    publish your policy (in CFEngine parlance these are `promise
    proposals') and the machines see the new proposals and can adjust
    accordingly. Each machine runs an agent that is capable of
    implementing policies and maintaining them over time without
    further assistance. 

Manage::
    Once a decision is made, unplanned events will occur. Such
    incidents traditionally set off alarms and humans rush to make new
    transactions to repair them.  In CFEngine, the autonomous agent
    manages the system, and you only have to deal with rare events
    that cannot be dealt with automatically. 

Audit::
    In traditional configuration systems, the outcome is far from
    clear after a one-shot transaction, so one audits the system to
    determine what actually happened. In CFEngine, changes are not
    just initiated once, but locally audited and maintained. Decision
    outcomes are assured by design in CFEngine and maintained
    automatically, so the main worry is managing conflicting
    intentions. Users can sit back and examine regular reports of
    compliance generated by the agents, without having to arrange for
    new `roll out' transactions.

ROLL-OUT and ROLL-BACK? You should not think of CFEngine as a roll-out
system, i.e. one that attempts to force out absolute changes and
perhaps reverse them in case of error. Roll-out and roll-back are
theoretically flawed concepts that only sometimes work in practice.
With CFEngine, you publish a sequence of policy revisions, always
moving forward (because like it or not, time only goes in one
direction). All of the desired-state changes are managed locally by
each individual computer, and continuously repaired to ensure on-going
compliance with policy.

=== Policy Decision Flow

CFEngine does not make absolute choices for you, like other tools.
Almost everything about its behavior is matter of policy and can be
changed. However, a structure for use, like the following, is
recommended (see the following figure).

In order to keep operations as simple as possible, CFEngine maintains
a private working directory on each machine referred to in
documentation as WORKDIR and in policy by the variable $(sys.workdir).
By default, this is located at /var/cfengine or C:\var\CFEngine. It
contains everything CFEngine needs to run.

The figure below shows how decisions flow through the parts of a
system.

* It makes sense to have a single point of coordination. Decisions are
therefore usually made in a single location (the Policy Definition
Point). The history of decisions and changes can be tracked by a
version control system of your choice (e.g. Subversion, CVS, etc.).

* Decisions are made by editing CFEngine's policy file promises.cf (or
one of its included sub-files). This process is carried out off-line.

* Once decisions have been formalized and coded, this new policy is
copied manually (a human decision) to a decision distribution point,
which by default is located in the directory /var/cfengine/masterfiles
on all policy distribution servers. 

In this introduction, we shall
assume that there is only one central policy distribution server, a
specially-appointed server which is referred to simple as the policy
server.

* Every client machine contacts the policy server and downloads these
updates. The policy server can be replicated if the number of clients
is very large, but we shall assume here that there is only one policy
server.

Once a client machine has a copy of the policy, it extracts only those
promise proposals that are relevant to it, and implements any changes
without human assistance. This is how CFEngine manages change.

WHY DO THIS? CFEngine tries to minimize dependencies by decoupling
processes. By following this pull-based architecture, CFEngine will
tolerate network outages and will recover from deployment errors
easily. By placing the burden of responsibility for decision at the
top, and for implementation at the bottom, we avoid needless fragility
and keep two independent quality assurance processes apart.
