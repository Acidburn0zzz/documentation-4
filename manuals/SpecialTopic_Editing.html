<html lang="en">
<head>
<title>Promising and Editing File Content</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Promising and Editing File Content">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
@font-face {
    font-family: 'CFE_FONT';
    src: url('fonts/eot/opensans-regular-webfont.eot');
    src: local('â˜º'),  url('fonts/ttf/opensans-regular-webfont.ttf') format('truetype'), url('fonts/svg/opensans-regular-webfont.svg') format('svg');
    font-weight: normal;
    font-style: normal;
}    
pre {
    background-color: #EEFFDD;
    border: 1px solid #CCCCCC;
    font-family: courier;
    margin-bottom: 10px;
    margin-top: 10px;
    padding: 5px;
    font-size: 90%;
    }
pre.display { font-family:inherit }
pre.format  { font-family:inherit }
pre.smallexample
pre.smalllisp,
pre.smallformat,
pre.smalldisplay {
  font-size: 90%;
} 

span.sc    { font-variant:small-caps }
span.roman { font-family:serif; font-weight:normal; } 
span.sansserif { font-family:sans-serif; font-weight:normal; } 

body {
    font:  90%  'CFE_FONT', arial, Helvetica,sans-serif; 
    color: #646464;
    padding: 10px 20px;
    width: 960px;
    margin: 0 auto;
}
.node
{
    text-align: right;
    padding: 2px;
    font-size: smaller;
}
.node hr {
    border: 0;
    width: 100%;
    color: #CCC;
    background-color: #CCC;
    height: 5px;
}
.section {
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
}

h1 {
    font-size: 26px;
    font-weight: normal;
    line-height: 32px;
    margin: 32px 0 16px;
    text-align: left;
    text-transform: uppercase;
}

h2 {
    color: #9E9981 !important;
    font-size: 16px;
    line-height: 18px;
    font-weight: normal;
    margin: 16px 0 26px;
    text-align: left;
}
h3 {
    margin-top: 3px;
    margin-right: 0px;
    margin-bottom: 10px;
    margin-left: 0px;
    line-height: 20px;
    font-size: 16px;
    font-weight: normal;
}

.contents
{
    background-color: #CCC;
    padding-top: 2px;
    padding-right: 2px;
    padding-bottom: 2px;
    padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 80%; }
 
.tynn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: smaller;
    font-style: normal;
    font-weight: lighter;
    margin-bottom: 0em;
    font-size: 11pt;
}
.verbatim {
    color: #000;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.example {
    color: #000;
    width: 100%;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 20px;
    margin-left: 0px;
}
.smallexample {
    color: #000;
    padding-top: 10px;
    padding-right: 30px;
    padding-bottom: 5px;
    padding-left: 30px;
    margin-top: 0px;
    margin-right: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
}
.cartouche {
    padding: 5px;
    font-style: italic;
    font-size: 85%;
}

table.cartouche {
    border: none !important;
}

 .cartouche td  {
    background: none !important;
    border: none !important;
    padding: 5px; 

/*    background-color: #ddd;
    border: 1px solid #ccc;
    padding: 5px;*/
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }
dt em {font-weight: bold}
/* don't change this rule */    
pre.sp {
    background: none !important;   
    border:none !important
}
/* --- */
/*code hightlight*/
.red { color: #b80047; font-weight: bold; }

.blue { color: blue;  /*font-weight: bold;*/ }

.green { color: darkgreen; }

.comment { font-style: italic; }
--></style>
</head>
<body>
<h1 class="settitle">Promising and Editing File Content</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#From-boiler_002dplates-to-convergent-file-editing">From boiler-plates to convergent file editing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Editing</h2>

<ul class="menu">
<li><a accesskey="1" href="#From-boiler_002dplates-to-convergent-file-editing">From boiler-plates to convergent file editing</a>
<li><a accesskey="2" href="#Why-is-file-editing-difficult_003f">Why is file editing difficult?</a>
<li><a accesskey="3" href="#What-does-file-editing-involve_003f">What does file editing involve?</a>
<li><a accesskey="4" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>
<li><a accesskey="5" href="#Constructing-files-from-promises">Constructing files from promises</a>
<li><a accesskey="6" href="#Editing-bundles">Editing bundles</a>
<li><a accesskey="7" href="#Choosing-an-approach-to-file-editing">Choosing an approach to file editing</a>
<li><a accesskey="8" href="#Pitfalls-to-watch-out-for-in-file-editing">Pitfalls to watch out for in file editing</a>
</ul>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<!-- ********************************************************************* -->
<div class="node">
<a name="From-boiler-plates-to-convergent-file-editing"></a>
<a name="From-boiler_002dplates-to-convergent-file-editing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-is-file-editing-difficult_003f">Why is file editing difficult?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">From boiler-plates to convergent file editing</h3>

<pre class="sp">

</pre>

Many configuration management systems allow you to determine
configuration file content to some extent, usually by over-writing
files with boiler-plate (template) files. This approach works for some
cases, but it is a blunt and inflexible instrument, which forces you
to take over the ownership of the file `all or nothing' and determine
its entire content yourself.  This is more than is necessary or
desirable in general.

   <p>Other approaches to file editing us search and replace, e.g. with the
long-standing Unix tools <samp><span class="file">awk</span></samp> and <samp><span class="file">sed</span></samp>. Adding a user to a
structured file such as the password file, only if the user is not
already defined, is a more complex operation.

   <p>Cfengine allows you to model both whole files and parts of files, in any
format, and promise that these fragments will satisfy certain promises
about their state.  This is potentially different from more common templating
approaches to file management in which pre-adjusted copies of files
are generated for all recipients at a single location and then
distributed.

   <p>The most important thing about making changes to files is that the
result end up being predictable. There are three ways to approach this
problem. You should choose the simplest approach that solves your
problem and try not to be prejudiced by what you have done before.

<!-- ********************************************************************* -->
<div class="node">
<a name="Why-is-file-editing-difficult%3f"></a>
<a name="Why-is-file-editing-difficult_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-does-file-editing-involve_003f">What does file editing involve?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#From-boiler_002dplates-to-convergent-file-editing">From boiler-plates to convergent file editing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Why is file editing difficult?</h3>

<pre class="sp">

</pre>

File content is not made up of simple data objects like permission flags or
process tables: files contain compound, ordered structures (known as
grammars) and they cannot always be determined from a single source of
information. To determine the outcome of a file we have to adopt either
a fully deterministic approach, or live with a partial approximation.

   <p>Some approaches to file editing try to `know' the intended format of a
file, by hardcoding it. If the file then fails to follow this format,
the algorithms might break. CFEngine gives you generic tools to be
able to handle files in any line-based format, without the need to
hard-code specialist knowledge about file formats.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
Remember that all changes are adapted to your local context and implemented at the final
destination by <code>cf-agent</code>. 
</td></tr></table>

<!-- ********************************************************************* -->
<div class="node">
<a name="What-does-file-editing-involve%3f"></a>
<a name="What-does-file-editing-involve_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-is-file-editing-difficult_003f">Why is file editing difficult?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">What does file editing involve?</h3>

<pre class="sp">

</pre>

There are several ways
to approach desired state management of file contents:

   <pre class="sp">

</pre>
     <ol type=1 start=1>
<li>Copy a finished file template to the desired location, completely overwriting existing content. 
<li>Copy and adapt an almost finished template, filling in variables or macros to yield a desired content. 
<li>Make corrections to whatever the existing state of the file might be.
        </ol>
   <pre class="sp">

</pre>
There are advantages and disadvantages with each of these approaches and the best approach depends on
the type of situation you need to describe.

   <pre class="sp">

</pre>
   <p><table summary=""><tr align="left"><td valign="top" width="50%"><b>For the approach</b> </td><td valign="top" width="50%"><b>Against the approach</b>
<br></td></tr><tr align="left"><td valign="top" width="50%">1. Deterministic. </td><td valign="top" width="50%">Hard to specialize the result and the source must still be maintained by hand. 
<br></td></tr><tr align="left"><td valign="top" width="50%">2. Deterministic. </td><td valign="top" width="50%">Limited specialization and must come from a single source, again maintained by hand. 
<br></td></tr><tr align="left"><td valign="top" width="50%">3. Non-deterministic/partial model. </td><td valign="top" width="50%">Full power to customize file even with multiple managers.
   <br></td></tr></table>
   <pre class="sp">

</pre>

   <p>Approaches 1 and 2 are best for situations where very few variations
of a file are needed in different circumstances.  Approach 3 is best
when you need to customize a file significantly, especially when you don't know the
full details of the file you are starting from. Approach 3 is generally required
when adapting configuration files provided by a third party, since the basic
content is determined by them.

<!-- ********************************************************************* -->
<div class="node">
<a name="Three-approaches-to-managing-files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Constructing-files-from-promises">Constructing files from promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-does-file-editing-involve_003f">What does file editing involve?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Three approaches to managing files</h3>

<ul class="menu">
<li><a accesskey="1" href="#Copying-a-finished-file-template-into-place">Copying a finished file template into place</a>
<li><a accesskey="2" href="#Contextual-adaptation-of-a-file-template">Contextual adaptation of a file template</a>
<li><a accesskey="3" href="#Example-file-template">Example file template</a>
<li><a accesskey="4" href="#Combining-copy-with-template-expansion">Combining copy with template expansion</a>
<li><a accesskey="5" href="#Making-delta-changes-to-someone-else_0027s-file">Making delta changes to someone else's file</a>
</ul>

<div class="node">
<a name="Copying-a-finished-file-template-into-place"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Contextual-adaptation-of-a-file-template">Contextual adaptation of a file template</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>

</div>

<h4 class="unnumberedsubsec">Copying a finished file template into place</h4>

<p>Use this approach if a simple substution of data will solve the problem in all contexts.

     <ol type=1 start=1>
<li>Maintain the content of the file in a version controlled repository. 
<li>Check out the file into a staging area. 
<li>Copy the file into place.
        </ol>

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent something
{
files:

  "/important/file"

  copy_from => secure_cp("/repository/important_file_template","svn-host");
}
</pre>
</td></tr></table>

<!-- ********************************************************************* -->
<div class="node">
<a name="Contextual-adaptation-of-a-file-template"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-file-template">Example file template</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying-a-finished-file-template-into-place">Copying a finished file template into place</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>

</div>

<h4 class="unnumberedsubsec">Contextual adaptation of a file template</h4>

<p>There are several approaches here:
     <ol type=1 start=1>
<li>Encode the boiler-plate template directly in the CFEngine configuration, and have full use of the power of the CFEngine language to adapt it. 
<li>Keep a separate boiler-plate file and edit/adapt it. 
<li>Copy a template from a repository then edit/adapt it. 
<li>Copy a generic template with embedded variables that can be expanded like macro-substitution.
        </ol>
Choose the approach that you consider to be simplest and most reliable for the purpose you need. 
Don't use templating, for instance, simply because it is what you are used to, or you might waste a lot
of time and effort maintaining data that you don't need to.

   <p>To expand a template file on a local disk:
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent templating
{
files:

  "/home/mark/tmp/file_based_on_template"

       create => "true",
    edit_line => expand_template("/tmp/source_template");
}
</pre>
</td></tr></table>
   As of CFEngine version 3.3.0 you can also use a new templating file format
and write:
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent templating
{
files:

  "/home/mark/tmp/file_based_on_template"

       create => "true",
    edit_template => "/tmp/source_template";
}
</pre>
</td></tr></table>

<p class="noindent">For example, the source template file might look like this, with
embedded CFEngine variables:
<pre class="example">     mail_relay = $(sys.fqhost)
     important_user = $(mybundle.variable)
     #...
</pre>
   <p class="noindent">These variables will be filled in by CFEngine assuming they are defined
within your CFEngine configuration.

   <p>If you use the new <code>edit_template</code> promise, you can embed directives to CFEngine
context-classes and mark out regions of a file to be treated as an iteratable
block.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">#This is a template file /templates/input.tmpl

These lines apply to anyone

[%CFEngine solaris.Monday:: %]
Everything after here applies only to solaris on Mondays
until overridden...

[%CFEngine linux:: %]
Everything after here now applies now to linux only.

[%CFEngine BEGIN %]
This is a block of text
That contains list variables: $(some.list)
With text before and after.
[%CFEngine END %]

nameserver $(some.list)
</pre>
</td></tr></table>

   <pre class="sp">

</pre>
For example: if we use this template in a promise:
   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent test
{
vars:
 "var" slist => { "1", "2", "3"};

files:
  "/tmp/expander"
         create => "true",
  edit_template => "/templates/input.tmpl";
}

</pre>
</td></tr></table>
   The result would look like this, on a linux host:
   <pre class="sp">

</pre>
<pre class="verbatim">#This is a template file /templates/input.tmpl

These lines apply to anyone
Everything after here now applies now to linux only.
This is a block of text
That contains list variables: 1
With text before and after.
This is a block of text
That contains list variables: 2
With text before and after.
This is a block of text
That contains list variables: 3
With text before and after.
nameserver 1
nameserver 2
nameserver 3
</pre>
   <pre class="sp">

</pre>

<div class="node">
<a name="Example-file-template"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Combining-copy-with-template-expansion">Combining copy with template expansion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Contextual-adaptation-of-a-file-template">Contextual adaptation of a file template</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>

</div>

<h4 class="unnumberedsubsec">Example file template</h4>

<pre class="sp">

</pre>
<pre class="verbatim">[%CFEngine any:: %]
&lt;VirtualHost $(sys.ipv4[eth0]):80>
        ServerAdmin             $(stage_file.params[apache_mail_address][1])
        DocumentRoot            /var/www/htdocs
        ServerName              $(stage_file.params[apache_server_name][1])
        AddHandler              cgi-script cgi
        ErrorLog                /var/log/httpd/error.log
        AddType                 application/x-x509-ca-cert .crt
        AddType                 application/x-pkcs7-crl    .crl
        SSLEngine               off
        CustomLog               /var/log/httpd/access.log
&lt;/VirtualHost>

[%CFEngine webservers_prod:: %]
[%CFEngine BEGIN %]
&lt;VirtualHost $(sys.ipv4[$(bundle.interfaces)]):443>                                               
        ServerAdmin             $(stage_file.params[apache_mail_address][1]) 
        DocumentRoot            /var/www/htdocs                                  
        ServerName              $(stage_file.params[apache_server_name][1])            
        AddHandler              cgi-script cgi                                 
        ErrorLog                /var/log/httpd/error.log                  
        AddType                 application/x-x509-ca-cert .crt                
        AddType                 application/x-pkcs7-crl    .crl                
        SSLEngine               on                                             
        SSLCertificateFile      $(stage_file.params[apache_ssl_crt][1])
        SSLCertificateKeyFile   $(stage_file.params[apache_ssl_key][1])
        CustomLog               /var/log/httpd/access.log                      
&lt;/VirtualHost>
[%CFEngine END %]

</pre>

<div class="node">
<a name="Combining-copy-with-template-expansion"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Making-delta-changes-to-someone-else_0027s-file">Making delta changes to someone else's file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-file-template">Example file template</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>

</div>

<h4 class="unnumberedsubsec">Combining copy with template expansion</h4>

<p>What about getting your template to the end-host?  To convergently
copy a file from a source and then edit it, use the following
construction with a staging file. 
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim">bundle agent master
{
files:
  "$(final_destination)"
         create => "true",
     edit_line => fix_file("$(staging_file)"),
 edit_defaults => empty,
         perms => mo("644","root"),
        action => if_elapsed("60");
}

bundle edit_line fix_file(f)
{
insert_lines:
  "$(f)"
     insert_type => "file";
     # expand_scalars => "true" ;

replace_patterns:
    "searchstring"
          replace_with => value("replacestring");
}

</pre>
</td></tr></table>

<!-- ********************************************************************* -->
<div class="node">
<a name="Making-delta-changes-to-someone-else's-file"></a>
<a name="Making-delta-changes-to-someone-else_0027s-file"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Combining-copy-with-template-expansion">Combining copy with template expansion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>

</div>

<h4 class="unnumberedsubsec">Making delta changes to someone else's file</h4>

<p>Edit a file with multiple promises about its state, when you do not want
to determine the entire content of the file, or if it is unsafe to
make unilateral changes, e.g. because its contents are also
being managed from another source like a software package manager.

   <p>For modifying a file, you have access to the full power of text editing
promises. This is a powerful framework.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="verbatim"># Resolve conf edit

body common control
{
bundlesequence => { "g", resolver(@(g.searchlist),@(g.nameservers)) };
inputs => { "cfengine_stdlib.cf" }; 
}

bundle common g # global
{
vars:
 "searchlist"  slist => { "example.com", "cfengine.com" };
 "nameservers" slist => { "10.1.1.10", "10.3.2.16", "8.8.8.8" };

classes:
  "am_name_server" 
     expression => reglist("@(nameservers)","$(sys.ipv4[eth1])");
}

bundle agent resolver(s,n)
{
files:
  "$(sys.resolv)"  # test on "/tmp/resolv.conf" #
      create        => "true",
      edit_line     => doresolv("@(this.s)","@(this.n)"),
      edit_defaults => empty;
}

# For your private library ......................

bundle edit_line doresolv(s,n)
{
insert_lines:
  "search $(s)";
  "nameserver $(n)";
delete_lines:
 # To clean out junk
  "nameserver .*| search .*" not_matching => "true";
}
</pre>
</td></tr></table>

<!-- ********************************************************************* -->
<div class="node">
<a name="Constructing-files-from-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Editing-bundles">Editing bundles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Three-approaches-to-managing-files">Three approaches to managing files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Constructing files from promises</h3>

<pre class="sp">

</pre>

Making finished templates for files and filling in the blanks using variables
is a flexble approach in many cases, but it is not flexible enough for all
cases. A very flexible approach, but one that requires more thought, is to build
a final result (desired end-state) from a set of promises about what the file
should contain. This might or might not include templates in the sense of complete
files that are read in.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
If you are using CFEngine 3.3 or later, you have the option of using <code>edit_template</code>
and its embedded language constructs to keep decisions and loops inside templates. Let's
set aside that for a while and look at the alternatives, placing the data entirely
within bundles of `edit'-promises. 
</td></tr></table>

   <p>There is language support for this kind of editing in the standard
library, and you can store data and template components within a
CFEngine configuration itself, or as a separate file.  For example:

<pre class="verbatim">#

body common control 
{
bundlesequence => { "main" };
inputs => { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

#

bundle common data
{
vars:
  "person" string => "Mary";
  "animal" string => "a little lamb";
}

#

bundle agent main
{
files:
   "/tmp/my_result"
        create => "true",
     edit_line => expand_template("/tmp/my_template_source"),
 edit_defaults => empty;
}

</pre>
Suppose the file <samp><span class="file">my_template_source</span></samp> contains the following
text:

<pre class="smallexample">        This is a file template containing variables to expand
     
        e.g $(data.person) had $(data.animal)
</pre>
   <pre class="sp">

</pre>
Then we would have the file content:
   <pre class="sp">

</pre>
<pre class="smallexample">     host$ more /tmp/my_result
        This is a file template containing variables to expand
     
        e.g Mary had a little lamb
</pre>
   <ul class="menu">
<li><a accesskey="1" href="#Adding-a-line-here-and-there">Adding a line here and there</a>
<li><a accesskey="2" href="#Lists-inline">Lists inline</a>
</ul>

<div class="node">
<a name="Adding-a-line-here-and-there"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Lists-inline">Lists inline</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Constructing-files-from-promises">Constructing files from promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Constructing-files-from-promises">Constructing files from promises</a>

</div>

<h4 class="unnumberedsubsec">Adding a line here and there</h4>

<p class="noindent">A simple file like this could also be defined in-line, without a separate template file:
<pre class="verbatim">#

body common control 
{
bundlesequence => { "main" };
inputs => { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

#

bundle common data
{
vars:
  "person" string => "Mary";
  "animal" string => "a little lamb";
}

#

bundle agent main
{
vars:
  "content" string => 
    "This is a file template containing variables to expand
e.g $(data.person) had $(data.animal)";

files:

   "/tmp/my_result"
        create => "true",
     edit_line => append_if_no_line("$(content)"),
 edit_defaults => empty;
}

</pre>

<div class="node">
<a name="Lists-inline"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Adding-a-line-here-and-there">Adding a line here and there</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Constructing-files-from-promises">Constructing files from promises</a>

</div>

<h4 class="unnumberedsubsec">Lists inline</h4>

<pre class="sp">

</pre>
Here is a more complicated example, that includes list expansion. List expansion (iteration)
adds some trickiness because it is an ordered process, which needs to be anchored somehow.
<pre class="verbatim">#

body common control 
{
bundlesequence => { "main" };
inputs => { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

#

bundle common data
{
vars:

  "person" string => "Mary";
  "animal" string => "a little lamb";

  "mylist" slist => { "one", "two", "three" };
  "clocks" slist => { "five", "six", "seven" };

  # or read the list from a file with readstringlist()

}

#

bundle agent main
{
files:


   "/tmp/my_result"

        create => "true",
     edit_line => my_expand_template,
 edit_defaults => empty;
}

#

bundle edit_line my_expand_template
{
vars:
 
 # import the lists, due to current limitation

 "mylist" slist => { @(data.mylist) };
 "clocks" string => join(", ","data.clocks");
 "other"  string => "eight";

insert_lines:

   "
   This is a file template containing variables to expand

   e.g $(data.person) had $(data.animal)

   and it said: 
   ";

   "
   $(mylist) o'clock ";
   "
   ROCK!
   $(clocks) o'clock, $(other) o'clock
   ";

   "   ROCK!
   The end.
   "

   insert_type => "preserve_block"; # So we keep duplicate line
}

</pre>
This results in a file output containing:
<pre class="smallexample">     host$ ~/LapTop/cfengine/core/src/cf-agent -f ./test.cf -K
     host$ more /tmp/my_result
     
        This is a file template containing variables to expand
     
        e.g Mary had a little lamb
     
        and it said:
     
        one o'clock
        two o'clock
        three o'clock
        ROCK!
        five, six, seven o'clock, eight o'clock
        ROCK!
        The end.
     
</pre>
   <p>Splitting this example into several promises seems unnecessary and inconvenient, so we could use a special
function <code>join()</code> to make pre-expand the scalar list and insert it as a single object:

<pre class="verbatim">#

body common control 
{
bundlesequence => { "main" };
inputs => { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

#

bundle common data
{
vars:

  "person" string => "Mary";
  "animal" string => "a little lamb";

  "mylist" slist => { "one", "two", "three", "" };
  "clocks" slist => { "five", "six", "seven" };

  # or read the list from a file with readstringlist()

}

#

bundle agent main
{
files:


   "/tmp/my_result"

        create => "true",
     edit_line => my_expand_template,
 edit_defaults => empty;
}

#

bundle edit_line my_expand_template
{
vars:
 
 # import the lists, due to current limitation

 "mylist" string => join(" o'clock$(const.n)  ","data.mylist");
 "clocks" string => join(", ","data.clocks");
 "other" string => "eight";

insert_lines:

   "
   This is a file template containing variables to expand

   e.g $(data.person) had $(data.animal)

   and it said: 

   $(mylist)
   ROCK!
   $(clocks) o'clock, $(other) o'clock
   ROCK!
   The end.
   "

   insert_type => "preserve_block"; # So we keep duplicate line
}

</pre>
Finally, since this is now entirely contained within a single set of quotes (i.e. there is a single
promiser), we could replace the in-line template with one read from a file:
<pre class="verbatim">#

body common control 
{
bundlesequence => { "main" };
inputs => { "LapTop/cfengine/copbl/cfengine_stdlib.cf" };
}

#

bundle common data
{
vars:

  "person" string => "Mary";
  "animal" string => "a little lamb";

  "mylist" slist => { "one", "two", "three", "" };
  "clocks" slist => { "five", "six", "seven" };

  # or read the list from a file with readstringlist()

}

#

bundle agent main
{
files:


   "/tmp/my_result"

        create => "true",
     edit_line => my_expand_template,
 edit_defaults => empty;
}

#

bundle edit_line my_expand_template
{
vars:
 
 # import the lists, due to current limitation

 "mylist" string => join(" o'clock$(const.n)  ","data.mylist");
 "clocks" string => join(", ","data.clocks");
 "other" string => "eight";

insert_lines:

   "/tmp/my_template_source"
     expand_scalars => "true",
     insert_type => "file"; 
}

</pre>
<!-- ********************************************************************* -->

<div class="node">
<a name="Editing-bundles"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Choosing-an-approach-to-file-editing">Choosing an approach to file editing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Constructing-files-from-promises">Constructing files from promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Editing bundles</h3>

<p>Unlike other aspects of configuration, promising the content of a single
file object involves possibly many promises about the atoms within the file. 
Thus we need to be able to state bundles of promises for what happens inside
a file and tie it (like a body-template) to the <code>files</code> promise. 
This is done using an <code>edit_line =&gt;</code> or <code>edit_xml =&gt;</code> constraint<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, for
instance:

<pre class="verbatim">files:

  "/etc/passwd"

     create => "true",

     # other constraints on file container ...

     edit_line => mybundle("one","two","three");
</pre>

   <p>Editing bundles are defined like other bundles for the agent, except that they have a type
given by the left hand side of the constraint (just like body templates):

<pre class="verbatim">bundle edit_line mybundle(arg1,arg2,arg3)
{
insert_lines:

   "newuser:x:1111:110:A new user:/home/newuser:/bin/bash";
   "$(arg1):x:$(arg2):110:$(arg3):/home/$(arg1):/bin/bash";
}
</pre>

<ul class="menu">
<li><a accesskey="1" href="#Standard-library-methods-for-simple-editing">Standard library methods for simple editing</a>
<li><a accesskey="2" href="#Expressing-expand_005ftemplate-as-promises">Expressing expand_template as promises</a>
</ul>

<div class="node">
<a name="Standard-library-methods-for-simple-editing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Expressing-expand_005ftemplate-as-promises">Expressing expand_template as promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Editing-bundles">Editing bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Editing-bundles">Editing bundles</a>

</div>

<h4 class="unnumberedsubsec">Standard library methods for simple editing</h4>

<p>You may choose to write your own editing bundles for specific purposes; you can also use
ready-made templates from the standard library for a lot of purposes. If you follow the
guidelines for choosing an approach to editing below, you will be able to re-use standard
methods in perhaps most cases. Using standard library code keeps your own intentions clear
and easily communicable. 
For example, to insert hello into a file at the end once only:
<pre class="verbatim">files:

  "/tmp/test_insert"

       create => "true",
    edit_line => append_if_no_line("hello"),
edit_defaults => empty;

</pre>
Or to set the shell for a user
<pre class="verbatim">files:

  "/etc/passwd"
       create    => "true",
       edit_line => set_user_field("mark","7","/my/favourite/shell");

</pre>

   <p>Some other examples of the standard editing methods are:

<pre class="verbatim"> append_groups_starting(v) 
 append_if_no_line(str) 
 append_if_no_lines(list) 
 append_user_field(group,field,allusers) 
 append_users_starting(v) 
 comment_lines_containing(regex,comment) 
 edit_line comment_lines_matching(regex,comment) 
 delete_lines_matching(regex) 
 expand_template(templatefile) 
 insert_lines(lines) 
 resolvconf(search,list) 
 set_user_field(user,field,val) 
 set_variable_values(v) 
 set_variable_values2(v) 
 uncomment_lines_containing(regex,comment) 
 uncomment_lines_matching(regex,comment) 
 warn_lines_matching(regex)
</pre>

   <p>You find these in the documentation for the COPBL.

<!-- ********************************************************************* -->
<div class="node">
<a name="Expressing-expand_template-as-promises"></a>
<a name="Expressing-expand_005ftemplate-as-promises"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Standard-library-methods-for-simple-editing">Standard library methods for simple editing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Editing-bundles">Editing bundles</a>

</div>

<h4 class="unnumberedsubsec">Expressing <code>expand_template</code> as promises</h4>

<p>As on CFEngine 3.3.0, CFEngine has a new template mechanism to make it
easier to encode complex file templates. These templates map simply to <code>edit_line</code> bundles
in the following way.

     <ul>
<li>Each line in a template maps to a separate <code>insert_lines</code> promise unless it is grouped with &lsquo;<samp><span class="samp">[%CFEngine BEGIN %]</span></samp>&rsquo; and &lsquo;<samp><span class="samp">[%CFEngine END %]</span></samp>&rsquo; tags. 
<li>Each multi-line group, marked with &lsquo;<samp><span class="samp">[%CFEngine BEGIN %]</span></samp>&rsquo; and &lsquo;<samp><span class="samp">[%CFEngine END %]</span></samp>&rsquo; tags maps to a multi-line <code>insert_lines</code> promise, with <code>insert_type =&gt; "preserve_block"</code>. 
<li>Each line that expresses a context-class: &lsquo;<samp><span class="samp">[%CFEngine </span><var>classexpression</var><span class="samp">:: %]</span></samp>&rsquo; maps to a normal
class expression in a bundle. 
</ul>

   <p>The order of lines in the template is preserved within each block, or if <code>edit_defaults</code> is used
to empty the resulting generated file before editing: e.g. with the standard library method:

<pre class="verbatim">
  "/tmp/expander"

           create => "true",
    edit_template => "/home/a10004/input.dat",
    edit_defaults => empty;

</pre>

<div class="node">
<a name="Choosing-an-approach-to-file-editing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pitfalls-to-watch-out-for-in-file-editing">Pitfalls to watch out for in file editing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Editing-bundles">Editing bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Choosing an approach to file editing</h3>

<p>There are two decisions to make when choosing how to manage file content:

     <dl>
<dt><i>How can the desired content be constructed from the necessary source(s)?</i><dd>Is there more than one source of infromation that needs to be merged?

     <br><dt><i>Do the contents need to be adapted to the specific environment?</i><dd>Is there context-specific information in the file? 
</dl>

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
Use the simplest approach that requires the smallest number of promises to solve the
problem. 
</td></tr></table>

<div class="node">
<a name="Pitfalls-to-watch-out-for-in-file-editing"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Choosing-an-approach-to-file-editing">Choosing an approach to file editing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h3 class="unnumberedsec">Pitfalls to watch out for in file editing</h3>

<p>File editing is different from most other kinds of configuration
promise because it is fundamentally an order dependent configuration
process. Files contain non-regular grammars. CFEngine attempts to simplify
the problem by using models for the file structure, essentially factoring out
as much of the context dependence as possible.

   <p>Order dependence increases the fragility of maintainence, so you should do what you can to minimize it.

     <ul>
<li>Try to use substitution within a known template if order is important. 
</ul>

   <p>The simplest kinds of files for configuration are line-based, with no special order. For such
cases, simple line insertions are usually enough to configure files.

   <p>The increasing introduction of XML for configuration is a major headache for configuration
management.

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Editing</a>
<ul>
<li><a href="#From-boiler_002dplates-to-convergent-file-editing">From boiler-plates to convergent file editing</a>
<li><a href="#Why-is-file-editing-difficult_003f">Why is file editing difficult?</a>
<li><a href="#What-does-file-editing-involve_003f">What does file editing involve?</a>
<li><a href="#Three-approaches-to-managing-files">Three approaches to managing files</a>
<ul>
<li><a href="#Copying-a-finished-file-template-into-place">Copying a finished file template into place</a>
<li><a href="#Contextual-adaptation-of-a-file-template">Contextual adaptation of a file template</a>
<li><a href="#Example-file-template">Example file template</a>
<li><a href="#Combining-copy-with-template-expansion">Combining copy with template expansion</a>
<li><a href="#Making-delta-changes-to-someone-else_0027s-file">Making delta changes to someone else's file</a>
</li></ul>
<li><a href="#Constructing-files-from-promises">Constructing files from promises</a>
<ul>
<li><a href="#Adding-a-line-here-and-there">Adding a line here and there</a>
<li><a href="#Lists-inline">Lists inline</a>
</li></ul>
<li><a href="#Editing-bundles">Editing bundles</a>
<ul>
<li><a href="#Standard-library-methods-for-simple-editing">Standard library methods for simple editing</a>
<li><a href="#Expressing-expand_005ftemplate-as-promises">Expressing <code>expand_template</code> as promises</a>
</li></ul>
<li><a href="#Choosing-an-approach-to-file-editing">Choosing an approach to file editing</a>
<li><a href="#Pitfalls-to-watch-out-for-in-file-editing">Pitfalls to watch out for in file editing</a>
</li></ul>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> At the time of writing
only <code>edit_line</code> is implemented.</p>

   <hr></div>

</body></html>

